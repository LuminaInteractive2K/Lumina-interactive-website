<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Biometric Identity Portraits - Interactive Demo</title>
    <style>
        :root {
            --primary: #ff6b6b;
            --secondary: #4ecdc4;
            --accent: #ffe66d;
            --background: #1a1a2e;
            --text: #e0e0fc;
            --panel: rgba(26, 26, 46, 0.9);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--background);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        header {
            padding: 1rem 2rem;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .main-content {
            flex: 1;
            display: flex;
            position: relative;
        }
        
        .visualization {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .portrait-container {
            position: relative;
            width: 60vh;
            height: 80vh;
            max-width: 80%;
            max-height: 80%;
            z-index: 5;
        }
        
        .side-panel {
            width: 350px;
            background-color: var(--panel);
            padding: 1.5rem;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            z-index: 10;
        }
        
        .panel-section {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }
        
        .panel-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        
        .biometric-indicator {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem;
            border-radius: 0.5rem;
            background-color: rgba(0, 0, 0, 0.2);
        }
        
        .indicator-icon {
            font-size: 1.5rem;
        }
        
        .indicator-details {
            flex: 1;
        }
        
        .indicator-label {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }
        
        .indicator-value {
            font-size: 1.1rem;
            color: var(--secondary);
        }
        
        .indicator-trend {
            font-size: 0.8rem;
            opacity: 0.7;
        }
        
        .visualization-style {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background-color: rgba(0, 0, 0, 0.2);
        }
        
        .style-label {
            flex: 1;
        }
        
        .style-preview {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin-left: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        #styleAbstract { background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #ffe66d); }
        #styleGeometric { background: repeating-linear-gradient(45deg, #ff6b6b, #ff6b6b 5px, #4ecdc4 5px, #4ecdc4 10px); }
        #styleFluid { background: radial-gradient(circle, #ff6b6b, #4ecdc4); }
        #styleTextured { background-image: url('data:image/svg+xml,%3Csvg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"%3E%3Cpath d="M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2" stroke="%23ffe66d" stroke-width="1"/%3E%3C/svg%3E'); background-color: #1a1a2e; }
        
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            background-color: var(--primary);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .btn:hover {
            background-color: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
        }
        
        .btn-secondary {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-secondary:hover {
            background-color: rgba(255, 255, 255, 0.2);
            box-shadow: none;
        }
        
        .btn-group {
            display: flex;
            gap: 0.5rem;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .modal-content {
            background-color: var(--panel);
            padding: 2rem;
            border-radius: 1rem;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(255, 107, 107, 0.3);
        }
        
        .close-modal {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .modal-title {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--primary);
            text-align: center;
        }
        
        .modal-section {
            margin-bottom: 1.5rem;
        }
        
        .modal-section-title {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            color: var(--secondary);
        }
        
        .sensor-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }
        
        .sensor-card {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            text-align: center;
        }
        
        .sensor-card:hover {
            background-color: rgba(0, 0, 0, 0.3);
        }
        
        .sensor-card.connected {
            border-color: var(--secondary);
        }
        
        .sensor-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }
        
        .sensor-name {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }
        
        .sensor-status {
            font-size: 0.8rem;
            opacity: 0.7;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--background);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 1s ease;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 107, 107, 0.2);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            color: var(--primary);
        }
        
        .loading-subtext {
            font-size: 0.9rem;
            opacity: 0.7;
            max-width: 400px;
            text-align: center;
        }
        
        .progress-bar {
            width: 300px;
            height: 6px;
            background-color: rgba(255, 107, 107, 0.1);
            border-radius: 3px;
            margin-top: 1rem;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background-color: var(--primary);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        @media (max-width: 900px) {
            .main-content {
                flex-direction: column-reverse;
            }
            .side-panel {
                width: 100%;
                height: 300px;
                border-left: none;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                overflow-x: auto;
                flex-direction: row;
                gap: 2rem;
            }
            .panel-section {
                min-width: 250px;
            }
            .portrait-container {
                width: 80vw;
                height: 60vh;
            }
        }
        
        @media (max-width: 600px) {
            header {
                padding: 0.75rem 1rem;
            }
            .logo {
                font-size: 1.2rem;
            }
            .side-panel {
                height: 250px;
                padding: 1rem;
            }
            .panel-title {
                font-size: 1rem;
            }
            .biometric-indicator {
                padding: 0.5rem;
                gap: 0.5rem;
            }
            .indicator-icon {
                font-size: 1.2rem;
            }
            .indicator-value {
                font-size: 1rem;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Initializing Biometric Identity Portrait</div>
        <div class="loading-subtext">Loading visualization engine and biometric models...</div>
        <div class="progress-bar">
            <div class="progress-fill"></div>
        </div>
    </div>
    
    <div class="container">
        <header>
            <div class="logo">BIOMETRIC IDENTITY PORTRAITS</div>
            <div class="btn-group">
                <button class="btn btn-secondary" id="helpBtn">Help</button>
                <button class="btn" id="connectBtn">Connect Sensors</button>
            </div>
        </header>
        
        <div class="main-content">
            <div class="visualization">
                <div class="portrait-container">
                    <canvas id="canvas"></canvas>
                </div>
            </div>
            
            <div class="side-panel">
                <div class="panel-section">
                    <div class="panel-title">Real-time Biometrics</div>
                    <div class="biometric-indicator">
                        <div class="indicator-icon">❤️</div>
                        <div class="indicator-details">
                            <div class="indicator-label">Heart Rate</div>
                            <div class="indicator-value" id="hrValue">72 bpm</div>
                            <div class="indicator-trend" id="hrTrend">Stable</div>
                        </div>
                    </div>
                    <div class="biometric-indicator">
                        <div class="indicator-icon">⚡</div>
                        <div class="indicator-details">
                            <div class="indicator-label">Skin Conductance</div>
                            <div class="indicator-value" id="gsrValue">1.5 µS</div>
                            <div class="indicator-trend" id="gsrTrend">Slightly increasing</div>
                        </div>
                    </div>
                    <div class="biometric-indicator">
                        <div class="indicator-icon">😊</div>
                        <div class="indicator-details">
                            <div class="indicator-label">Facial Expression</div>
                            <div class="indicator-value" id="faceValue">Neutral</div>
                            <div class="indicator-trend" id="faceTrend">Calm</div>
                        </div>
                    </div>
                    <div class="biometric-indicator">
                        <div class="indicator-icon">🧠</div>
                        <div class="indicator-details">
                            <div class="indicator-label">Brainwaves (Alpha)</div>
                            <div class="indicator-value" id="eegValue">65%</div>
                            <div class="indicator-trend" id="eegTrend">Relaxed focus</div>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="panel-title">Visualization Style</div>
                    <div class="visualization-style">
                        <span class="style-label">Abstract Flow</span>
                        <div class="style-preview" id="styleAbstract"></div>
                        <input type="radio" name="vizStyle" value="abstract" checked style="margin-left: 0.5rem;">
                    </div>
                    <div class="visualization-style">
                        <span class="style-label">Geometric Patterns</span>
                        <div class="style-preview" id="styleGeometric"></div>
                        <input type="radio" name="vizStyle" value="geometric" style="margin-left: 0.5rem;">
                    </div>
                    <div class="visualization-style">
                        <span class="style-label">Fluid Dynamics</span>
                        <div class="style-preview" id="styleFluid"></div>
                        <input type="radio" name="vizStyle" value="fluid" style="margin-left: 0.5rem;">
                    </div>
                    <div class="visualization-style">
                        <span class="style-label">Textured Layers</span>
                        <div class="style-preview" id="styleTextured"></div>
                        <input type="radio" name="vizStyle" value="textured" style="margin-left: 0.5rem;">
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="panel-title">Actions</div>
                    <button class="btn" id="captureBtn">Capture Portrait</button>
                    <button class="btn btn-secondary" id="resetBtn">Reset</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="helpModal">
        <div class="modal-content">
            <button class="close-modal" id="closeHelpModal">×</button>
            <h2 class="modal-title">Biometric Identity Portraits Help</h2>
            
            <div class="modal-section">
                <h3 class="modal-section-title">About</h3>
                <p>Biometric Identity Portraits create a living, evolving digital representation of you, generated in real-time from your unique biological data. Watch as your inner state is translated into a beautiful, abstract artwork.</p>
            </div>
            
            <div class="modal-section">
                <h3 class="modal-section-title">Biometric Inputs</h3>
                <ul style="margin-left: 1.5rem; line-height: 1.6;">
                    <li><strong>Heart Rate (HR):</strong> Influences rhythmic patterns and pulse-like effects.</li>
                    <li><strong>Skin Conductance (GSR):</strong> Affects color intensity and emotional expression.</li>
                    <li><strong>Facial Expression:</strong> Shapes the overall composition and mood.</li>
                    <li><strong>Brainwaves (EEG):</strong> Modulates complexity and texture (requires EEG headset).</li>
                </ul>
            </div>
            
            <div class="modal-section">
                <h3 class="modal-section-title">Visualization Styles</h3>
                <p>Choose how your biometric data is visually interpreted:</p>
                <ul style="margin-left: 1.5rem; line-height: 1.6;">
                    <li><strong>Abstract Flow:</strong> Smooth, flowing colors and shapes.</li>
                    <li><strong>Geometric Patterns:</strong> Structured, crystalline formations.</li>
                    <li><strong>Fluid Dynamics:</strong> Liquid-like movements and interactions.</li>
                    <li><strong>Textured Layers:</strong> Rich, layered textures and organic forms.</li>
                </ul>
            </div>
            
            <div class="modal-section">
                <h3 class="modal-section-title">Connecting Sensors</h3>
                <p>Use the "Connect Sensors" button to manage connections to compatible biometric devices. The system supports standard Bluetooth sensors, webcams, and various EEG headsets. Simulation mode is active if no sensors are connected.</p>
            </div>
        </div>
    </div>
    
    <div class="modal" id="connectModal">
        <div class="modal-content">
            <button class="close-modal" id="closeConnectModal">×</button>
            <h2 class="modal-title">Connect Biometric Sensors</h2>
            
            <div class="modal-section">
                <h3 class="modal-section-title">Available Devices</h3>
                <div class="sensor-list">
                    <div class="sensor-card" data-sensor="hr">
                        <div class="sensor-icon">❤️</div>
                        <div class="sensor-name">Heart Rate Monitor</div>
                        <div class="sensor-status">Not connected</div>
                    </div>
                    <div class="sensor-card" data-sensor="gsr">
                        <div class="sensor-icon">⚡</div>
                        <div class="sensor-name">GSR Sensor</div>
                        <div class="sensor-status">Not connected</div>
                    </div>
                    <div class="sensor-card" data-sensor="face">
                        <div class="sensor-icon">😊</div>
                        <div class="sensor-name">Webcam</div>
                        <div class="sensor-status">Not connected</div>
                    </div>
                    <div class="sensor-card" data-sensor="eeg">
                        <div class="sensor-icon">🧠</div>
                        <div class="sensor-name">EEG Headset</div>
                        <div class="sensor-status">Not connected</div>
                    </div>
                </div>
            </div>
            
            <div class="modal-section" style="text-align: center;">
                <button class="btn" id="simulateBtn">Use Simulation Mode</button>
            </div>
        </div>
    </div>

    <!-- Inline SimplexNoise implementation -->
    <script>
        // SimplexNoise implementation
        class SimplexNoise {
            constructor(randomOrSeed) {
                const random = typeof randomOrSeed === 'function' ? randomOrSeed : Math.random;
                this.p = new Uint8Array(256);
                this.perm = new Uint8Array(512);
                this.permMod12 = new Uint8Array(512);
                
                // Fill p with values from 0 to 255
                for (let i = 0; i < 256; i++) {
                    this.p[i] = i;
                }
                
                // Shuffle the array
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(random() * (i + 1));
                    [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
                }
                
                // Copy to perm and permMod12
                for (let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                    this.permMod12[i] = this.perm[i] % 12;
                }
            }
            
            // 2D simplex noise
            noise2D(x, y) {
                const F2 = 0.5 * (Math.sqrt(3) - 1);
                const G2 = (3 - Math.sqrt(3)) / 6;
                
                const s = (x + y) * F2;
                const i = Math.floor(x + s);
                const j = Math.floor(y + s);
                
                const t = (i + j) * G2;
                const X0 = i - t;
                const Y0 = j - t;
                const x0 = x - X0;
                const y0 = y - Y0;
                
                let i1, j1;
                if (x0 > y0) {
                    i1 = 1;
                    j1 = 0;
                } else {
                    i1 = 0;
                    j1 = 1;
                }
                
                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1 + 2 * G2;
                const y2 = y0 - 1 + 2 * G2;
                
                const ii = i & 255;
                const jj = j & 255;
                
                const gi0 = this.permMod12[ii + this.perm[jj]];
                const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]];
                const gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]];
                
                let n0 = 0;
                let t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 >= 0) {
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
                }
                
                let n1 = 0;
                let t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 >= 0) {
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
                }
                
                let n2 = 0;
                let t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 >= 0) {
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
                }
                
                return 70 * (n0 + n1 + n2);
            }
            
            // 3D simplex noise
            noise3D(x, y, z) {
                const F3 = 1 / 3;
                const G3 = 1 / 6;
                
                const s = (x + y + z) * F3;
                const i = Math.floor(x + s);
                const j = Math.floor(y + s);
                const k = Math.floor(z + s);
                
                const t = (i + j + k) * G3;
                const X0 = i - t;
                const Y0 = j - t;
                const Z0 = k - t;
                
                const x0 = x - X0;
                const y0 = y - Y0;
                const z0 = z - Z0;
                
                let i1, j1, k1;
                let i2, j2, k2;
                
                if (x0 >= y0) {
                    if (y0 >= z0) {
                        i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;
                    } else if (x0 >= z0) {
                        i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1;
                    } else {
                        i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1;
                    }
                } else {
                    if (y0 < z0) {
                        i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1;
                    } else if (x0 < z0) {
                        i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1;
                    } else {
                        i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0;
                    }
                }
                
                const x1 = x0 - i1 + G3;
                const y1 = y0 - j1 + G3;
                const z1 = z0 - k1 + G3;
                const x2 = x0 - i2 + 2 * G3;
                const y2 = y0 - j2 + 2 * G3;
                const z2 = z0 - k2 + 2 * G3;
                const x3 = x0 - 1 + 3 * G3;
                const y3 = y0 - 1 + 3 * G3;
                const z3 = z0 - 1 + 3 * G3;
                
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                
                const gi0 = this.permMod12[ii + this.perm[jj + this.perm[kk]]];
                const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]];
                const gi2 = this.permMod12[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]];
                const gi3 = this.permMod12[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]];
                
                let n0 = 0;
                let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
                if (t0 >= 0) {
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0);
                }
                
                let n1 = 0;
                let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
                if (t1 >= 0) {
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1);
                }
                
                let n2 = 0;
                let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
                if (t2 >= 0) {
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2);
                }
                
                let n3 = 0;
                let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
                if (t3 >= 0) {
                    t3 *= t3;
                    n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3);
                }
                
                return 32 * (n0 + n1 + n2 + n3);
            }
            
            dot(g, ...args) {
                return g.reduce((sum, value, i) => sum + value * args[i], 0);
            }
            
            // Gradient vectors for 3D
            grad3 = [
                [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
                [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
                [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
            ];
        }

        // Make SimplexNoise available globally
        window.SimplexNoise = SimplexNoise;
    </script>

    <script>
        // Wait for DOM content to load
        document.addEventListener('DOMContentLoaded', function() {
            // Check if THREE is loaded
            if (typeof THREE === 'undefined') {
                console.error('THREE is not defined. Loading fallback...');
                // Create a minimal THREE fallback
                window.THREE = {
                    Scene: function() { this.add = function() {}; },
                    PerspectiveCamera: function() {},
                    WebGLRenderer: function() { 
                        return { 
                            setSize: function() {}, 
                            render: function() {},
                            setPixelRatio: function() {},
                            domElement: document.createElement('canvas')
                        }; 
                    },
                    Color: function() {},
                    Vector2: function() {},
                    Vector3: function() {},
                    ShaderMaterial: function() {},
                    PlaneGeometry: function() {},
                    Mesh: function() { this.position = { set: function() {} }; },
                    Clock: function() { this.getElapsedTime = function() { return 0; }; }
                };
            }

            // Initialize the application
            init();
        });

        // Global variables
        let scene, camera, renderer;
        let portraitMesh;
        let clock;
        let noise;
        let currentStyle = 'abstract';
        let biometricData = {
            heartRate: 72,
            skinConductance: 1.5,
            facialExpression: 0.5, // 0 = negative, 0.5 = neutral, 1 = positive
            brainwaves: 0.65
        };
        let simulationMode = true;
        let animationId;

        function init() {
            // Initialize noise generator
            noise = new SimplexNoise();
            
            // Initialize Three.js scene
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.z = 1;
            
            // Get the canvas element
            const canvas = document.getElementById('canvas');
            
            // Initialize renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: true
            });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Initialize clock for animation
            clock = new THREE.Clock();
            
            // Create portrait mesh
            createPortraitMesh();
            
            // Initialize event listeners
            initEventListeners();
            
            // Start simulation
            startSimulation();
            
            // Start animation loop
            animate();
            
            // Simulate loading
            simulateLoading();
        }

        function createPortraitMesh() {
            // Define shader material
            const portraitMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    heartRate: { value: biometricData.heartRate / 100 },
                    skinConductance: { value: biometricData.skinConductance / 10 },
                    facialExpression: { value: biometricData.facialExpression },
                    brainwaves: { value: biometricData.brainwaves },
                    styleMode: { value: getStyleValue() }
                },
                vertexShader: `
                    varying vec2 vUv;
                    
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float heartRate;
                    uniform float skinConductance;
                    uniform float facialExpression;
                    uniform float brainwaves;
                    uniform int styleMode;
                    
                    varying vec2 vUv;
                    
                    // Simplex noise function
                    float snoise(vec2 v) {
                        const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                                -0.577350269189626, 0.024390243902439);
                        vec2 i  = floor(v + dot(v, C.yy));
                        vec2 x0 = v -   i + dot(i, C.xx);
                        vec2 i1;
                        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                        vec4 x12 = x0.xyxy + C.xxzz;
                        x12.xy -= i1;
                        i = mod(i, 289.0);
                        vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
                        vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
                        m = m*m;
                        m = m*m;
                        vec3 x = 2.0 * fract(p * C.www) - 1.0;
                        vec3 h = abs(x) - 0.5;
                        vec3 ox = floor(x + 0.5);
                        vec3 a0 = x - ox;
                        m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
                        vec3 g;
                        g.x  = a0.x  * x0.x  + h.x  * x0.y;
                        g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                        return 130.0 * dot(m, g);
                    }
                    
                    vec3 permute(vec3 x) {
                        return mod(((x*34.0)+1.0)*x, 289.0);
                    }
                    
                    void main() {
                        vec2 uv = vUv;
                        vec3 color;
                        
                        // Base colors influenced by facial expression (emotional state)
                        vec3 colorA = mix(vec3(0.1, 0.2, 0.3), vec3(0.8, 0.2, 0.3), facialExpression * 0.5);
                        vec3 colorB = mix(vec3(0.1, 0.1, 0.3), vec3(0.2, 0.5, 0.8), facialExpression);
                        vec3 colorC = mix(vec3(0.2, 0.1, 0.2), vec3(0.8, 0.8, 0.1), facialExpression * 0.7);
                        
                        // Different visualization styles
                        if (styleMode == 0) { // Abstract Flow
                            // Flowing noise patterns
                            float n1 = snoise(uv * 3.0 + time * 0.1 * heartRate);
                            float n2 = snoise(uv * 5.0 - time * 0.15 * heartRate + 10.0);
                            float n3 = snoise(uv * 7.0 + time * 0.05 * heartRate + 20.0);
                            
                            // Combine noise with colors
                            color = colorA * n1 + colorB * n2 + colorC * n3;
                            
                            // Add pulsing effect based on heart rate
                            float pulse = sin(time * 3.0 * heartRate) * 0.1 + 0.9;
                            color *= pulse;
                            
                            // Add intensity based on skin conductance
                            color = mix(color, vec3(1.0), skinConductance * 0.3);
                            
                        } else if (styleMode == 1) { // Geometric Patterns
                            // Create grid pattern
                            float gridSize = mix(5.0, 20.0, brainwaves);
                            vec2 grid = fract(uv * gridSize);
                            float cellNoise = snoise(floor(uv * gridSize) * 0.1 + time * 0.1);
                            
                            // Create geometric shapes
                            float circle = length(grid - 0.5);
                            float square = max(abs(grid.x - 0.5), abs(grid.y - 0.5));
                            float shape = mix(circle, square, cellNoise);
                            
                            // Apply colors based on shape value
                            color = mix(colorA, colorB, shape);
                            
                            // Add variation based on skin conductance
                            color = mix(color, colorC, sin(shape * 10.0 + time + skinConductance));
                            
                        } else if (styleMode == 2) { // Fluid Dynamics
                            // Create fluid-like effect
                            float t = time * 0.2;
                            float n1 = snoise(uv * 2.0 + vec2(t * heartRate, t * 0.5));
                            float n2 = snoise(uv * 4.0 + vec2(-t * 0.6, t * 0.3));
                            float n3 = snoise(uv * 8.0 + vec2(t * 0.4, -t * 0.7));
                            
                            // Create fluid streams
                            float stream = n1 * 0.5 + n2 * 0.3 + n3 * 0.2;
                            
                            // Apply colors with fluid blending
                            color = mix(colorA, colorB, stream);
                            color = mix(color, colorC, sin(stream * 6.28 + time));
                            
                            // Add turbulence based on skin conductance
                            float turbulence = snoise(uv * 10.0 * skinConductance + time * 0.1);
                            color += turbulence * 0.1;
                            
                        } else { // Textured Layers
                            // Create multiple texture layers
                            float layers = 5.0;
                            float depth = 0.0;
                            vec3 layerColor = vec3(0.0);
                            
                            for (float i = 0.0; i < 5.0; i++) {
                                float fi = i / layers;
                                float scale = mix(3.0, 15.0, fi);
                                float speed = mix(0.05, 0.2, fi) * heartRate;
                                
                                // Layer noise
                                float n = snoise(uv * scale + time * speed + fi * 10.0);
                                
                                // Layer depth and color
                                float layerDepth = smoothstep(0.3, 0.7, n) * (1.0 - fi);
                                vec3 currentColor = mix(colorA, mix(colorB, colorC, fi), n);
                                
                                // Accumulate layers
                                layerColor = mix(layerColor, currentColor, layerDepth);
                                depth += layerDepth;
                            }
                            
                            // Normalize and apply final color
                            color = layerColor / max(depth, 1.0);
                            
                            // Add texture variation based on brainwaves
                            float textureDetail = snoise(uv * 20.0 * brainwaves + time * 0.05);
                            color *= 0.8 + textureDetail * 0.2;
                        }
                        
                        // Apply overall intensity based on skin conductance
                        color = mix(color, vec3(1.0), skinConductance * 0.2);
                        
                        // Apply overall mood tint based on facial expression
                        if (facialExpression < 0.4) { // Negative mood
                            color = mix(color, vec3(0.1, 0.0, 0.2), 0.3);
                        } else if (facialExpression > 0.6) { // Positive mood
                            color = mix(color, vec3(0.8, 0.7, 0.2), 0.2);
                        }
                        
                        // Apply complexity variation based on brainwaves
                        float complexity = snoise(uv * 30.0 * brainwaves + time * 0.02);
                        color = mix(color, color * complexity, 0.1);
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `
            });
            
            // Create portrait geometry and mesh
            const portraitGeometry = new THREE.PlaneGeometry(1.8, 2.4, 1, 1);
            portraitMesh = new THREE.Mesh(portraitGeometry, portraitMaterial);
            scene.add(portraitMesh);
        }

        function getStyleValue() {
            switch(currentStyle) {
                case 'abstract': return 0;
                case 'geometric': return 1;
                case 'fluid': return 2;
                case 'textured': return 3;
                default: return 0;
            }
        }

        function initEventListeners() {
            // Help button
            document.getElementById('helpBtn').addEventListener('click', function() {
                document.getElementById('helpModal').classList.add('active');
            });
            document.getElementById('closeHelpModal').addEventListener('click', function() {
                document.getElementById('helpModal').classList.remove('active');
            });
            
            // Connect button
            document.getElementById('connectBtn').addEventListener('click', function() {
                document.getElementById('connectModal').classList.add('active');
            });
            document.getElementById('closeConnectModal').addEventListener('click', function() {
                document.getElementById('connectModal').classList.remove('active');
            });
            
            // Simulate button
            document.getElementById('simulateBtn').addEventListener('click', function() {
                simulationMode = true;
                document.getElementById('connectModal').classList.remove('active');
                startSimulation();
            });
            
            // Sensor cards
            document.querySelectorAll('.sensor-card').forEach(card => {
                card.addEventListener('click', function() {
                    const sensorType = this.dataset.sensor;
                    // In a real implementation, this would attempt to connect to the sensor
                    // For this demo, we'll just toggle the connected state
                    this.classList.toggle('connected');
                    this.querySelector('.sensor-status').textContent = 
                        this.classList.contains('connected') ? 'Connected' : 'Not connected';
                });
            });
            
            // Visualization style radio buttons
            document.querySelectorAll('input[name="vizStyle"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    currentStyle = this.value;
                    if (portraitMesh && portraitMesh.material && portraitMesh.material.uniforms) {
                        portraitMesh.material.uniforms.styleMode.value = getStyleValue();
                    }
                });
            });
            
            // Capture button
            document.getElementById('captureBtn').addEventListener('click', function() {
                // In a real implementation, this would save the current state
                alert('Portrait captured! In a full implementation, this would save your current biometric portrait.');
            });
            
            // Reset button
            document.getElementById('resetBtn').addEventListener('click', function() {
                // Reset biometric data to defaults
                biometricData = {
                    heartRate: 72,
                    skinConductance: 1.5,
                    facialExpression: 0.5,
                    brainwaves: 0.65
                };
                
                // Update UI
                updateBiometricDisplay();
                
                // Update shader uniforms
                if (portraitMesh && portraitMesh.material && portraitMesh.material.uniforms) {
                    portraitMesh.material.uniforms.heartRate.value = biometricData.heartRate / 100;
                    portraitMesh.material.uniforms.skinConductance.value = biometricData.skinConductance / 10;
                    portraitMesh.material.uniforms.facialExpression.value = biometricData.facialExpression;
                    portraitMesh.material.uniforms.brainwaves.value = biometricData.brainwaves;
                }
            });
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            const canvas = document.getElementById('canvas');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            renderer.setSize(width, height);
        }

        function startSimulation() {
            if (!simulationMode) return;
            
            // Clear any existing simulation
            if (animationId) {
                clearInterval(animationId);
            }
            
            // Start simulation loop
            animationId = setInterval(function() {
                // Simulate changes in biometric data
                biometricData.heartRate = 65 + Math.sin(Date.now() * 0.001) * 15;
                biometricData.skinConductance = 1.0 + Math.sin(Date.now() * 0.0005) * 0.8;
                biometricData.facialExpression = 0.3 + Math.sin(Date.now() * 0.0003) * 0.4;
                biometricData.brainwaves = 0.4 + Math.sin(Date.now() * 0.0002) * 0.4;
                
                // Update UI
                updateBiometricDisplay();
                
                // Update shader uniforms
                if (portraitMesh && portraitMesh.material && portraitMesh.material.uniforms) {
                    portraitMesh.material.uniforms.heartRate.value = biometricData.heartRate / 100;
                    portraitMesh.material.uniforms.skinConductance.value = biometricData.skinConductance / 10;
                    portraitMesh.material.uniforms.facialExpression.value = biometricData.facialExpression;
                    portraitMesh.material.uniforms.brainwaves.value = biometricData.brainwaves;
                }
            }, 1000);
        }

        function updateBiometricDisplay() {
            // Update heart rate display
            document.getElementById('hrValue').textContent = Math.round(biometricData.heartRate) + ' bpm';
            if (biometricData.heartRate < 65) {
                document.getElementById('hrTrend').textContent = 'Relaxed';
            } else if (biometricData.heartRate > 85) {
                document.getElementById('hrTrend').textContent = 'Elevated';
            } else {
                document.getElementById('hrTrend').textContent = 'Stable';
            }
            
            // Update skin conductance display
            document.getElementById('gsrValue').textContent = biometricData.skinConductance.toFixed(1) + ' µS';
            if (biometricData.skinConductance < 1.0) {
                document.getElementById('gsrTrend').textContent = 'Calm';
            } else if (biometricData.skinConductance > 1.8) {
                document.getElementById('gsrTrend').textContent = 'Aroused';
            } else {
                document.getElementById('gsrTrend').textContent = 'Slightly increasing';
            }
            
            // Update facial expression display
            if (biometricData.facialExpression < 0.3) {
                document.getElementById('faceValue').textContent = 'Negative';
                document.getElementById('faceTrend').textContent = 'Sad/Frustrated';
            } else if (biometricData.facialExpression > 0.7) {
                document.getElementById('faceValue').textContent = 'Positive';
                document.getElementById('faceTrend').textContent = 'Happy/Excited';
            } else {
                document.getElementById('faceValue').textContent = 'Neutral';
                document.getElementById('faceTrend').textContent = 'Calm';
            }
            
            // Update brainwaves display
            document.getElementById('eegValue').textContent = Math.round(biometricData.brainwaves * 100) + '%';
            if (biometricData.brainwaves < 0.4) {
                document.getElementById('eegTrend').textContent = 'Low focus';
            } else if (biometricData.brainwaves > 0.7) {
                document.getElementById('eegTrend').textContent = 'Deep focus';
            } else {
                document.getElementById('eegTrend').textContent = 'Relaxed focus';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Update time uniform
            if (portraitMesh && portraitMesh.material && portraitMesh.material.uniforms) {
                portraitMesh.material.uniforms.time.value = clock.getElapsedTime();
            }
            
            // Render scene
            renderer.render(scene, camera);
        }

        function simulateLoading() {
            const loadingOverlay = document.querySelector('.loading-overlay');
            const progressFill = document.querySelector('.progress-fill');
            const loadingText = document.querySelector('.loading-text');
            const loadingSubtext = document.querySelector('.loading-subtext');
            
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 15;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(interval);
                    
                    loadingText.textContent = 'Biometric Portrait Ready';
                    loadingSubtext.textContent = 'Explore your living artwork...';
                    
                    setTimeout(() => {
                        loadingOverlay.style.opacity = 0;
                        setTimeout(() => {
                            loadingOverlay.style.display = 'none';
                        }, 1000);
                    }, 500);
                }
                
                progressFill.style.width = `${progress}%`;
                
                if (progress > 30 && progress < 60) {
                    loadingSubtext.textContent = 'Calibrating biometric models...';
                } else if (progress >= 60 && progress < 90) {
                    loadingSubtext.textContent = 'Generating visualization shaders...';
                }
            }, 200);
        }
    </script>
</body>
</html>
